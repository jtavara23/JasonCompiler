/* Generated By:JavaCC: Do not edit this line. Tester.java */
import java.io.*;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class Tester implements TesterConstants {

        public final static tabelaSimbolos ts = new tabelaSimbolos();
        public static ArrayList<String> palavrasReservadas = new ArrayList<String>();
        public static ArrayList<String> tipoPrimitivo = new ArrayList<String>();
        public static ArrayList<ArrayList<String>> P = new ArrayList<ArrayList<String>>();
        public static Map<String, Map<Integer,Integer > > posVariaveis = new HashMap<String, Map<Integer,Integer > >();
        public static Map<String, String> funtionLabels = new HashMap<String, String>();
        public static int contLabel = 0;
        public static int flag = 0;
        public static int nivel = 0;
        public static int actualVar = 0;
        public static int actualParam = -3;
        public static int indiceParametro = 0;
        public static ArrayList<String> cmd;
        public static ArrayList<String> ids = new ArrayList<String>();
        public static ArrayList<Integer> dmem = new ArrayList<Integer>();
        public static ArrayList<String> parametros = new ArrayList<String>();

        public static boolean isInteger(String str){
                try {
                Integer.parseInt(str);
                return true;
        } catch (NumberFormatException nfe) {}
        return false;
        }
        public static boolean isReal(String str){
                try {
                Double.parseDouble(str);
                return true;
        } catch (NumberFormatException nfe) {}
        return false;

        }
        public static boolean isString(String str){
                if(str.charAt(0) == '\u005c'')
                        return true;
                return false;
        }

        static public void main(String args[]) {
        try
                {
                        palavrasReservadas.add("array");palavrasReservadas.add("endwhile");palavrasReservadas.add("program");
                        palavrasReservadas.add("begin");palavrasReservadas.add("function");palavrasReservadas.add("read");
                        palavrasReservadas.add("then");palavrasReservadas.add("call");palavrasReservadas.add("if");
                        palavrasReservadas.add("types");palavrasReservadas.add("do");palavrasReservadas.add("record");
                        palavrasReservadas.add("until");palavrasReservadas.add("else");palavrasReservadas.add("parameters");
                        palavrasReservadas.add("return");palavrasReservadas.add("variables");palavrasReservadas.add("end");
                        palavrasReservadas.add("set");palavrasReservadas.add("while");palavrasReservadas.add("endif");
                        palavrasReservadas.add("procedure");palavrasReservadas.add("write");palavrasReservadas.add("enduntil");
                        palavrasReservadas.add("returns");palavrasReservadas.add("var");

            tipoPrimitivo.add("real");tipoPrimitivo.add("integer");tipoPrimitivo.add("string");
                        Tester analizador = new Tester( System.in ) ;
                        analizador.Program();
                        System.out.println("Terminou a analise!");

                }
                catch(ParseException e)
                {
                        System.out.println(e.getMessage());
                        System.out.println("Analisador: Encontrou erros durante a analise!");
                }
        }

/*
void Program():
{Token t;}
{
	(t = <ADD> 			{System.out.println("@("+t.beginLine+","+t.beginColumn+") ADD           - "+t.image);}
	| t = <SUB>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") SUB           - "+t.image);}
	| t = <MULT>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") MULT          - "+t.image);}
	| t = <DIV>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") DIV           - "+t.image);}
	| t = <IGUAL>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") IGUAL         - "+t.image);}
	| t = <MENOR>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") MENOR         - "+t.image);}
	| t = <MAIOR>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") MAIOR         - "+t.image);}
	| t = <DIFERENTE>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") DIFERENTE     - "+t.image);}
	| t = <MENORIGUAL>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") MENORIGUAL    - "+t.image);}
	| t = <MAIORIGUAL>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") MAIORIGUAL    - "+t.image);}
	| t = <IDENTIFIER>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") IDENTIFICADORR- "+t.image);}
	| t = <NUMERO>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") NUMERO        - "+t.image);}
	| t = <PONTOVIRGULA>{System.out.println("@("+t.beginLine+","+t.beginColumn+") PONTOVIRGULA  - "+t.image);}
	| t = <VIRGULA>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") VIRGULA       - "+t.image);}
	| t = <ABREPAR>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") ABREPAR       - "+t.image);}
	| t = <FECPAR>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") FECHAPAR      - "+t.image);}
	| t = <ABRECOL>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") ABRECOL       - "+t.image);}
	| t = <FECHACOL>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") FECHACOL      - "+t.image);}
	| t = <NAO>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") NAO           - "+t.image);}
	| t = <CADEIA>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") CADEIA        - "+t.image);}
	| t = <ARRAY>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") ARRAY         - "+t.image);}
	| t = <ENDWHILE>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") ENDWHILE      - "+t.image);}
	| t = <PROGRAM>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") PROGRAM       - "+t.image);}
	| t = <BEGIN>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") BEGIN         - "+t.image);}
	| t = <FUNCTION>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") FUNCTION      - "+t.image);}
	| t = <READ>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") READ          - "+t.image);}
	| t = <THEN>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") THEN          - "+t.image);}
	| t = <CALL>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") CALL          - "+t.image);}
	| t = <IF>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") IF            - "+t.image);}
	| t = <REAL>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") REAL          - "+t.image);}
	| t = <TYPES>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") TYPES         - "+t.image);}
	| t = <DO>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") DO            - "+t.image);}
	| t = <INTEGER>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") INTEGER       - "+t.image);}
	| t = <RECORD>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") RECORD        - "+t.image);}
	| t = <UNTIL>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") UNTIL         - "+t.image);}
	| t = <ELSE>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") ELSE          - "+t.image);}
	| t = <PARAMETERS>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") PARAMETERS    - "+t.image);}
	| t = <RETURN>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") RETURN        - "+t.image);}
	| t = <VARIABLES>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") VARIABLES     - "+t.image);}
	| t = <END>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") END           - "+t.image);}
	| t = <SET>			{System.out.println("@("+t.beginLine+","+t.beginColumn+") SET           - "+t.image);}
	| t = <WHILE>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") WHILE         - "+t.image);}
	| t = <ENDIF>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") ENDIF         - "+t.image);}
	| t = <PROCEDURE>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") PROCEDURE     - "+t.image);}
	| t = <STRING>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") STRING        - "+t.image);}
	| t = <WRITE>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") WRITE         - "+t.image);}
	| t = <ENDUNTIL>	{System.out.println("@("+t.beginLine+","+t.beginColumn+") ENDUNTIL      - "+t.image);}
	| t = <RETURNS>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") RETURNS       - "+t.image);}
	| t = <VAR> 		{System.out.println("@("+t.beginLine+","+t.beginColumn+") VAR           - "+t.image);}
	| t = <DOT> 		{System.out.println("@("+t.beginLine+","+t.beginColumn+") DOT           - "+t.image);})*
}
*/
  static final public Token Identifier(boolean instancia) throws ParseException {
    Token t;
    t = jj_consume_token(IDENTIFIER);
        String id = t.image.toString();
        if(palavrasReservadas.contains(id.toLowerCase())||tipoPrimitivo.contains(id.toLowerCase()))
            System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctO identifier nao pode ser uma palavra reservada!");
        else if(ts.existType(id))
            System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct Identifier "+t.image.toString()+" nao pode ser um tipo de dado!");
        else if(ts.existId(id)&&instancia)
            System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctVariavel "+t.image.toString()+" ja foi definida.");
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public String criarRotulo() throws ParseException {
                contLabel++;
                {if (true) return "L"+contLabel;}
    throw new Error("Missing return statement in function");
  }

  static final public String usaRotulo() throws ParseException {
                {if (true) return "L"+contLabel;}
    throw new Error("Missing return statement in function");
  }

  static final public void addHash(String ident) throws ParseException {
                Map myMap = new HashMap<Integer, Integer>();
        myMap.put(nivel,actualVar);
                actualVar++;
                posVariaveis.put(ident,myMap);
  }

  static final public void addHashParam(int nParametros) throws ParseException {
                for(int i = 0; i < nParametros; i++) {
                        Map myMap = new HashMap<Integer, Integer>();
                myMap.put(nivel,actualParam);
                        actualParam--;
                        posVariaveis.put(ids.get(ids.size()-1),myMap);
                        ids.remove(ids.size()-1);
                }
  }

  static final public void addCmd(String label, String comando, String par1, String par2) throws ParseException {
                ArrayList<String> cmd = new ArrayList<String>();
                cmd.add(label);
                cmd.add(comando);
                cmd.add(par1);
                cmd.add(par2);
                P.add(cmd);
  }

  static final public void geraCodigo() throws ParseException {
                try {
                        File file = new File("codigo.txt");
                        if (!file.exists()) {
                                file.createNewFile();
                        }
                        FileWriter fw = new FileWriter(file.getAbsoluteFile());
                        BufferedWriter bw = new BufferedWriter(fw);
                        for(int i = 0; i < P.size(); i++) {
                                bw.write(P.get(i).get(0) + "\u005ct" + P.get(i).get(1) + "\u005ct" + P.get(i).get(2) + "\u005ct" + P.get(i).get(3) + "\u005cn");
                        }
                        bw.close();
                } catch (IOException e) {
                        e.printStackTrace();
                }
  }

//Programa e Bloco

//1.  Program ::= Header DeclSec Block
  static final public void Program() throws ParseException {
                addCmd("", "INPP", "", "");
    Header();
    DeclSec();
    Block();
    jj_consume_token(DOT);
                ts.removeLevelScope();
                addCmd("", "PARA", "", "");
                geraCodigo();
  }

//2.  Header ::= program identifier ;
  static final public void Header() throws ParseException {
    Token t;
    jj_consume_token(PROGRAM);
    t = Identifier(false);
        String id = t.image.toString();
        if(!palavrasReservadas.contains(id.toLowerCase())&&!tipoPrimitivo.contains(id.toLowerCase()))
        {
            ts.addDescritor(id,"PROGRAM");
        }
        else
            System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctO identifier nao pode ser uma palavra reservada!");
    jj_consume_token(PONTOVIRGULA);
  }

//3.  Block ::= begin Statements end
  static final public void Block() throws ParseException {
    jj_consume_token(BEGIN);
    Statements();
    jj_consume_token(END);
        addCmd("", "DMEM", "" + dmem.get(dmem.size()-1), "");
        dmem.remove(dmem.size()-1);
  }

//DeclaraÃ§Ãµes//

//4.  DeclSec ::= TypeDeclSec VarDeclSec SubProgramDecls
  static final public void DeclSec() throws ParseException {
        String rotulo = "";
    TypeDeclSec();
    VarDeclSec();
                rotulo = criarRotulo();
                addCmd("", "DSVS", rotulo, "");
    SubProgramDecls();
                addCmd(rotulo, "NADA", "", "");
  }

//5.  TypeDeclSec ::= [types TypeDecls]
  static final public void TypeDeclSec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPES:
      jj_consume_token(TYPES);
      TypeDecls();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
  }

//6.  TypeDecls ::= TypeDecl+
  static final public void TypeDecls() throws ParseException {
    label_1:
    while (true) {
      TypeDecl();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

//7.  TypeDecl ::= identifier TypeSpecification
  static final public void TypeDecl() throws ParseException {
        Token t;
    t = Identifier(false);
                String idTipo=t.image.toString();
                if(!palavrasReservadas.contains(idTipo.toLowerCase())&&!tipoPrimitivo.contains(idTipo.toLowerCase()))
                        if(!ts.addDescritor(idTipo,"TYPE"))
                                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctO Tipo "+t.image.toString()+" ja foi definido nesse contexto.");
    TypeSpecification(idTipo);
  }

//8.  TypeSpecification ::= (ArraySpecification |  RecordSpecification)
  static final public void TypeSpecification(String idTipo) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARRAY:
      ArraySpecification(idTipo);
      break;
    case RECORD:
      RecordSpecification(idTipo);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//9.  ArraySpecification ::= array DataType â€œ[â€œnumericliteralâ€?]â€?;
  static final public void ArraySpecification(String idArray) throws ParseException {
        Token t;
    jj_consume_token(ARRAY);
    t = DataType();
                if(ts.existId(idArray)) {//Verifica si el id existe en el escopo actual
                        Descritor desIdArray = ts.searchScopeAtual(idArray);
                        if(desIdArray.getRotulo().compareToIgnoreCase("TYPE")==0) {// Verifica si es un Type 
                                if(idArray.compareToIgnoreCase(t.image.toString())==0)
                                        System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct O DataType: " +t.image.toString()+" precisa  ser diferente ao identifier.");
                                else {
                                        desIdArray.getCategoria().set("ELEMTYPE","ARRAY");
                                        Descritor dataTipo = ts.initDataType(t.image.toString());
                                        ((ArrayTipo)((Tipo)desIdArray.getCategoria()).get("ELEMTYPE")).set("ELEMTYPE",dataTipo);
                                }
                        }
                }
    jj_consume_token(ABRECOL);
    t = jj_consume_token(INTEIRO);
                if(isInteger(t.image.toString())) {
                        int size = Integer.parseInt(t.image.toString());
                                if(size>0)
                                        ((ArrayTipo)((Tipo)ts.searchScopeAtual(idArray).getCategoria()).get("ELEMTYPE")).set("SIZE",size);
                                else
                                        System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct O indice nao pode ser negativo: "+t.image.toString());
                } else
            System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct O indice nao \u00c3\u00a9 um inteiro: "+t.image.toString());
    jj_consume_token(FECHACOL);
    jj_consume_token(PONTOVIRGULA);
  }

//10. RecordSpecification ::= record VarDecls end;
  static final public void RecordSpecification(String idRecord) throws ParseException {
            if(ts.existId(idRecord))//Verifica si el id existe en el escopo actual
            {
                Descritor desRecordTipo = ts.searchDataType(idRecord);
                if(desRecordTipo.getRotulo().compareToIgnoreCase("TYPE")==0)// Verifica si es un Type           
                    desRecordTipo.getCategoria().set("ELEMTYPE","RECORD");
            }
    jj_consume_token(RECORD);
    VarDecls(idRecord, true);
    jj_consume_token(END);
    jj_consume_token(PONTOVIRGULA);
  }

//11. VarDeclSec ::= [variables VarDecls]
  static final public void VarDeclSec() throws ParseException {
        int n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLES:
      jj_consume_token(VARIABLES);
                flag = 4;
      n = VarDecls("",false);
                addCmd("", "AMEM", "" + n, "");
                dmem.add(n);
                flag = 0;
                actualVar = 0;
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
  }

//12. VarDecls ::= (VarDecl)+
  static final public int VarDecls(String idTipo, boolean origenRecord) throws ParseException {
        int total = 0, n = 0;
    label_2:
    while (true) {
      n = VarDecl(idTipo, origenRecord);
                                            total += n;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REAL:
      case INTEGER:
      case STRING:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
    }
                {if (true) return total;}
    throw new Error("Missing return statement in function");
  }

//13. VarDecl ::= DataType IdList ;
  static final public int VarDecl(String idTipo, boolean origenRecord) throws ParseException {
        Token t; int n;
    t = DataType();
    n = IdList(idTipo, t, origenRecord);
    jj_consume_token(PONTOVIRGULA);
                {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

//14. DataType ::= (real | integer | identifier | string)
  static final public Token DataType() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REAL:
      t = jj_consume_token(REAL);
      break;
    case INTEGER:
      t = jj_consume_token(INTEGER);
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                if(!ts.existType(t.image.toString()))
                        System.out.println("Erro semantico na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctTipo "+t.image.toString()+" nao esta definido.");
      break;
    case STRING:
      t = jj_consume_token(STRING);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

//15. IdList ::= identifier {, identifier}
  static final public int IdList(String idTipo, Token dataT, boolean origenRecord) throws ParseException {
        Token t; int n = 1;
    t = Identifier(true);
                addRecordData(idTipo,dataT, t, origenRecord);
                if(flag==4)
                        addHash(t.image.toString());
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(VIRGULA);
      t = Identifier(true);
                addRecordData(idTipo,dataT, t, origenRecord);
                if(flag==4)
                        addHash(t.image.toString());
                n++;
    }
                {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

//Java Code
  static final public void addRecordData(String idTipo,Token dataT, Token id, boolean origenRecord) throws ParseException {
                if(origenRecord)//TYPERECORD
                {
                    if(ts.existId(idTipo))//Verifica si el id existe en el escopo actual       
                    {
                        Descritor desIdTipo = ts.searchScopeAtual(idTipo);
                        if(desIdTipo.getRotulo().compareToIgnoreCase("TYPE")==0)// Verifica si es un Type           				
                            if(ts.existType(dataT.image.toString()))
                            {
                                Descritor dataTipo = ts.initDataType(dataT.image.toString());
                                if(!palavrasReservadas.contains(id.image.toString())&&!ts.existType(id.image.toString()))
                                {
                                        boolean result =((RecordTipo)((Tipo)desIdTipo.getCategoria()).get("ELEMTYPE")).set(id.image.toString(),dataTipo);
                                        if(!result)
                                                System.out.println("Erro semantico na linha "+id.beginLine+", coluna "+id.beginColumn+".\u005cn\u005ctIdentificador "+id.image.toString()+" ja foi definido.");
                                }
                            }
                    }
                }
                else //VARIABLES
                {
                    if(ts.existType(dataT.image.toString())&&!ts.existId(id.image.toString())
                            &&!palavrasReservadas.contains(id.image.toString().toLowerCase())
                            &&!ts.existType(id.image.toString()))//Solo si existe dataType y el id no fue definido en el mismo escopo
                    {
                        Descritor dataTipo = ts.initDataType(dataT.image.toString());
                        if(ts.addDescritor(id.image.toString(),"VARIABLE"))
                            ((Variavel)ts.searchVariable(id.image.toString()).getCategoria()).set("ELEMTYPE",dataTipo);
                    }
                }
  }

//16. SubProgramDecls ::= (SubProgramDecl)*
  static final public void SubProgramDecls() throws ParseException {
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNCTION:
      case PROCEDURE:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      SubProgramDecl();
    }
  }

//17. SubProgramDecl ::= (ProcDecl | FunctionDecl)
  static final public void SubProgramDecl() throws ParseException {
        String rotulo;
        int nParametros;
                rotulo = criarRotulo();
                addCmd(rotulo, "NADA", "", "");
                nivel++;
                addCmd("", "ENPR", "" + nivel, "");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PROCEDURE:
      nParametros = ProcDecl();
                addCmd("", "RTPR", "" + nParametros, "");
      break;
    case FUNCTION:
      FunctionDecl();
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                nivel--;
                ts.removeLevelScope();
  }

//18. ProcDecl ::= ProcHeader SubProgramDeclSec Block;
  static final public int ProcDecl() throws ParseException {
        String nameP;
        int nParametros;
    nameP = ProcHeader();
                funtionLabels.put(nameP, usaRotulo());
    nParametros = SubProgramDeclSec(nameP);
    Block();
    jj_consume_token(PONTOVIRGULA);
                {if (true) return nParametros;}
    throw new Error("Missing return statement in function");
  }

//19. ProcHeader ::= procedure identifier ;
  static final public String ProcHeader() throws ParseException {
        Token t;
    jj_consume_token(PROCEDURE);
    t = Identifier(true);
    jj_consume_token(PONTOVIRGULA);
                String nameP = t.image.toString();
                ts.addDescritor(nameP, "PROCEDURE");
                ts.addLevelScope();
                {if (true) return nameP;}
    throw new Error("Missing return statement in function");
  }

//20. SubProgramDeclSec ::= ParamDeclSec DeclSec
  static final public int SubProgramDeclSec(String nameSubPrograma) throws ParseException {
        int nParametros=0;
    nParametros = ParamDeclSec(nameSubPrograma);
                if(ts.searchId(ts.getscopeAtual()-1,nameSubPrograma))
                {
                    String subProg = ts.search(ts.getscopeAtual()-1,nameSubPrograma).getRotulo();
                    if(subProg.compareTo("FUNCTION")==0||subProg.compareTo("PROCEDURE")==0)
                        ts.search(ts.getscopeAtual()-1, nameSubPrograma).getCategoria().set("NPARAMS", nParametros);
                }
    DeclSec();
                {if (true) return nParametros;}
    throw new Error("Missing return statement in function");
  }

//21. ParamDeclSec ::= [parameters ParamDecls]
  static final public int ParamDeclSec(String nameSubPrograma) throws ParseException {
        int nParametros=0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAMETERS:
      jj_consume_token(PARAMETERS);
      nParametros = ParamDecls(nameSubPrograma);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
                addHashParam(nParametros);
                {if (true) return nParametros;}
    throw new Error("Missing return statement in function");
  }

//22. ParamDecls ::= (ParamDecl)+
  static final public int ParamDecls(String nameSubPrograma) throws ParseException {
        int nParametros=0;
    label_5:
    while (true) {
      nParametros = ParamDecl(nParametros,nameSubPrograma);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REAL:
      case INTEGER:
      case STRING:
      case VAR:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
    }
                {if (true) return nParametros;}
    throw new Error("Missing return statement in function");
  }

//23. ParamDecl ::= [var]DataType identifier;
  static final public int ParamDecl(int nParametros,String nameSubPrograma) throws ParseException {
        String classParam="VALUE";
        Token dataT;
        Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      jj_consume_token(VAR);
                classParam = "REFERENCE";
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    dataT = DataType();
    id = Identifier(true);
    jj_consume_token(PONTOVIRGULA);
                if(!palavrasReservadas.contains(id.image.toString().toLowerCase())&&!ts.existType(id.image.toString())&&!ts.existId(id.image.toString())&&ts.existType(dataT.image.toString())) {
                        ts.addDescritor(id.image.toString(), "PARAM");
                        Descritor descParam = ts.searchScopeAtual(id.image.toString());
                        ((Parametro)descParam.getCategoria()).set("ELEMTYPE", ts.initDataType(dataT.image.toString()));
                        ((Parametro)descParam.getCategoria()).set("TCLASS", classParam);
                        Descritor subProgram = ts.search(ts.getscopeAtual()-1,nameSubPrograma);
                        subProgram.getCategoria().set(id.image.toString(),descParam);
                }
        ids.add(id.image.toString());
        {if (true) return nParametros+1;}
    throw new Error("Missing return statement in function");
  }

//24. FunctionDecl ::= FunctionHeader SubProgramDeclSec FunctionBlock ;
  static final public void FunctionDecl() throws ParseException {
        String[] returnFHeader;
    returnFHeader = FunctionHeader();
    SubProgramDeclSec(returnFHeader[0]);
    FunctionBlock(returnFHeader[1]);
    jj_consume_token(PONTOVIRGULA);
  }

//25. FunctionHeader ::= function identifier returns Datatype ;
  static final public String[] FunctionHeader() throws ParseException {
        Token id;
        Token tipoR;
        String[] returnFHeader = new String[2];
    jj_consume_token(FUNCTION);
    id = Identifier(true);
    jj_consume_token(RETURNS);
    tipoR = DataType();
    jj_consume_token(PONTOVIRGULA);
                String nameF = id.image.toString();
                ts.addDescritor(nameF, "FUNCTION");
                if(ts.existId(nameF))
                {
                    if(ts.searchScopeAtual(nameF).getRotulo().compareTo("FUNCTION")==0&&ts.existType(tipoR.image.toString()))
                    {
                                                ((Function)ts.searchScopeAtual(nameF).getCategoria()).set("RTYPE", ts.initDataType(tipoR.image.toString()));
                    }
                }
                ts.addLevelScope();
                returnFHeader[0] = nameF;
                returnFHeader[1] = tipoR.image.toString();
                {if (true) return returnFHeader;}
    throw new Error("Missing return statement in function");
  }

//26. FunctionBlock ::= begin SpecialStatements end  
  static final public void FunctionBlock(String rType) throws ParseException {
    jj_consume_token(BEGIN);
    SpecialStatements(rType);
    jj_consume_token(END);
  }

//Comandos //

//27. Statements ::= Statement {; Statement}
  static final public void Statements() throws ParseException {
    Statement();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PONTOVIRGULA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      jj_consume_token(PONTOVIRGULA);
      Statement();
    }
  }

//28. SpecialStatements ::= Statement; {Statement;} ReturnStatement 
  static final public void SpecialStatements(String rType) throws ParseException {
    label_7:
    while (true) {
      Statement();
      jj_consume_token(PONTOVIRGULA);
      if (jj_2_1(2)) {
        ;
      } else {
        break label_7;
      }
    }
    ReturnStatement(rType);
  }

/*29. Statement ::= [(read  Variable | set  Variable = Expresion
| write  Variable
| if Condition then Statements ElseClause
| while Condition do Statements endwhile
| until Condition do Statements enduntil
| call identifier ArgList)]*/
  static final public void Statement() throws ParseException {
        Token t;
        String tipo1, tipo2, arrayType, rotulo, rotulo2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case READ:
    case CALL:
    case IF:
    case UNTIL:
    case SET:
    case WHILE:
    case WRITE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case READ:
        t = jj_consume_token(READ);
                addCmd("", "LEIT", "", "");
                flag = 1;
        tipo1 = Variable(true, null, false);
                msgError(tipo1,t);
        break;
      case SET:
                flag = 5;
        jj_consume_token(SET);
        tipo1 = Variable(true, null, false);
        t = jj_consume_token(IGUAL);
        tipo2 = Expression();
                addCmd(cmd.get(0), cmd.get(1), cmd.get(2), cmd.get(3));
                if(tipo1.compareToIgnoreCase("_NULO_")!=0)
                {
                        //if(tipo1.compareToIgnoreCase("VETOR")!=0 && tipo1.compareToIgnoreCase("RECORD")!=0)
                                //if(ts.searchDataType(tipo1).getRotulo().compareToIgnoreCase("TYPE")==0)
                                        //tipo1 = ((Descritor)((Categoria)((Tipo)ts.searchDataType(tipo1).getCategoria()).get("ELEMTYPE")).get("ELEMTYPE")).getRotulo();
                                if(tipo1.compareToIgnoreCase(tipo2)!=0)
                                        if(tipo1.compareToIgnoreCase(tipo2)!=0)
                                                System.out.println("Erro semantica na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctTipos incompativeis("+tipo1+" diferente de "+tipo2+")!");

                }
                else
                        System.out.println("Erro semantica na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctVariable inexistente");
        break;
      case WRITE:
        t = jj_consume_token(WRITE);
                flag =2;
        tipo1 = Variable(true, null, false);
                addCmd("","IMPR","","");
                msgError(tipo1,t);
        break;
      case IF:
        t = jj_consume_token(IF);
                rotulo = criarRotulo();
        tipo1 = Condition();
        jj_consume_token(THEN);
        Statements();
                rotulo2 = criarRotulo();
                addCmd("", "DSVS", rotulo2, "");
                addCmd(rotulo, "NADA", "", "");
        ElseClause();
                msgCondError(tipo1,t);
                addCmd(rotulo2, "NADA", "", "");
        break;
      case WHILE:
        t = jj_consume_token(WHILE);
                rotulo = criarRotulo();
                rotulo2 = criarRotulo();
                addCmd(rotulo, "NADA", "", "");
        tipo1 = Condition();
        jj_consume_token(DO);
        Statements();
        jj_consume_token(ENDWHILE);
                addCmd("", "DSVS", rotulo, "");
                addCmd(rotulo2, "NADA", "", "");
                msgCondError(tipo1,t);
        break;
      case UNTIL:
        t = jj_consume_token(UNTIL);
        tipo1 = Condition();
        jj_consume_token(DO);
        Statements();
        jj_consume_token(ENDUNTIL);
                msgCondError(tipo1,t);
        break;
      case CALL:
        jj_consume_token(CALL);
        t = Identifier(false);
                Descritor identChpr=ts.search(0,t.image.toString());
                if(identChpr == null)
                        System.out.println("nullllaso");
                if(identChpr.getRotulo().compareToIgnoreCase("FUNCTION")==0)
                        addCmd("", "AMEN 1","", "");
                //Olhamos si a function ou procedimento tem parametros
                if(identChpr.getRotulo().compareToIgnoreCase("FUNCTION")==0||identChpr.getRotulo().compareToIgnoreCase("PROCEDURE")==0)
                {
                        Categoria dataTypeId=identChpr.getCategoria();
                        int nPar=(int)dataTypeId.get("NPARAMS");
                        for(int p=0;p<nPar;p++)
                        {
                                Categoria paraChpr=(Categoria)((Descritor)(dataTypeId.get(String.valueOf(p)))).getCategoria();
                                parametros.add((String)paraChpr.get("TCLASS"));

                        }
                }
        ArgList(t,true);
                addCmd("", "CHPR", funtionLabels.get(t.image.toString()), "");
                parametros = new ArrayList<String>();
                indiceParametro = 0 ;
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  static final public void msgError(String tipo, Token t) throws ParseException {
                if(tipo.compareToIgnoreCase("INTEGER")!=0 && tipo.compareToIgnoreCase("REAL") !=0 && tipo.compareToIgnoreCase("STRING")!=0)
                        System.out.println("Erro semantica na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctTipo invalido para condicao.\u005cn\u005ctEsperado: INTEGER, REAL ou STRING, encontrado: "+tipo);
  }

  static final public void msgCondError(String tipo, Token t) throws ParseException {
        if(tipo.compareToIgnoreCase("INTEGER")!=0)
                System.out.println("Erro semantica na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctTipo invalido para condicao.\u005cn\u005ctEsperado: INTEGER, encontrado: "+tipo);
  }

//30. ElseClause ::= (else Statements endif | endif
  static final public void ElseClause() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      Statements();
      jj_consume_token(ENDIF);
      break;
    case ENDIF:
      jj_consume_token(ENDIF);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//31. ReturnStatement ::= return â€œ(â€œ Condition â€œ)â€?
  static final public void ReturnStatement(String rType) throws ParseException {
        Token t;
        String returned;
    jj_consume_token(RETURN);
    t = jj_consume_token(ABREPAR);
    returned = Condition();
    jj_consume_token(FECPAR);
                if(returned.compareToIgnoreCase(rType)!=0)
                        System.out.println("Erro semantico na linha: "+t.beginLine+", coluna: "+t.beginColumn+".\u005cn\u005ctTipo retornado nao esperado!");
  }

//32. ArgList ::= [â€œ(â€œ Arguments â€œ)â€?]
  static final public void ArgList(Token t,boolean chpr) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABREPAR:
      jj_consume_token(ABREPAR);
      Arguments(t);
      jj_consume_token(FECPAR);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
  }

//33. ArgListSpecial ::= â€œ(â€œ Arguments â€œ)â€? 
  static final public void ArgListSpecial() throws ParseException {
    jj_consume_token(ABREPAR);
    Arguments(null);
    jj_consume_token(FECPAR);
  }

//34. Arguments ::= Argument {, Argument}
  static final public void Arguments(Token t) throws ParseException {
    Argument();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_8;
      }
         indiceParametro++;
      jj_consume_token(VIRGULA);
      Argument();
    }
  }

//ExpressÃµes//

//35. Condition ::= CompoundCondition {\ CompoundCondition}
  static final public String Condition() throws ParseException {
        Token top = null;
        String op, tipo1, tipo2;
        boolean hasReal = false, error = false;
    tipo1 = CompoundCondition();
        if(tipo1.compareToIgnoreCase("STRING")==0 || tipo1.compareToIgnoreCase("_NULO_")==0)
                error = true;
        if(tipo1.compareToIgnoreCase("INTEGER")!=0)
                hasReal = true;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OU:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_9;
      }
      top = jj_consume_token(OU);
      tipo2 = CompoundCondition();
        if(tipo2.compareToIgnoreCase("STRING")==0 || tipo1.compareToIgnoreCase("_NULO_")==0)
                error = true;
        if(tipo2.compareToIgnoreCase("INTEGER")!=0)
                hasReal = true;
    }
        if(top == null)
                {if (true) return tipo1;}
        else if(!error && !hasReal)
                {if (true) return "INTEGER";}
        else if (!error)
                {if (true) return "REAL";}
        else
                {if (true) return "_NULO_";}
    throw new Error("Missing return statement in function");
  }

//36. CompoundCondition ::= SimpleCondition {& SimpleCondition}
  static final public String CompoundCondition() throws ParseException {
        Token top = null;
        String op, tipo1, tipo2;
        boolean hasReal = false, error = false;
    tipo1 = SimpleCondition();
        if(tipo1.compareToIgnoreCase("STRING")==0 || tipo1.compareToIgnoreCase("_NULO_")==0)
                error = true;
        if(tipo1.compareToIgnoreCase("INTEGER")!=0)
                hasReal = true;
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case E:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_10;
      }
      top = jj_consume_token(E);
      tipo2 = SimpleCondition();
        if(tipo2.compareToIgnoreCase("STRING")==0 || tipo1.compareToIgnoreCase("_NULO_")==0)
                error = true;
        if(tipo2.compareToIgnoreCase("INTEGER")!=0)
                hasReal = true;
    }
        if(top == null)
                {if (true) return tipo1;}
        else if(!error && !hasReal)
                {if (true) return "INTEGER";}
        else if (!error)
                {if (true) return "REAL";}
        else
                {if (true) return "_NULO_";}
    throw new Error("Missing return statement in function");
  }

//37. SimpleCondition ::= Expression [RelOp Expression]
  static final public String SimpleCondition() throws ParseException {
        Token top;
        String op, tipo1, tipo2;
    tipo1 = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IGUAL:
    case MENOR:
    case MAIOR:
    case DIFERENTE:
    case MENORIGUAL:
    case MAIORIGUAL:
      top = RelOp();
      tipo2 = Expression();
        switch(top.image.toString()){
                case "=":
                        addCmd("", "CMIG", "", "");
                        break;
                case ">":
                        addCmd("", "CMMA", "", "");
                        break;
                case "<":
                        addCmd("", "CMME", "", "");
                        break;
                case ">=":
                        addCmd("", "CMAG", "", "");
                        break;
                case "<=":
                        addCmd("", "CMEG", "", "");
                        break;
                case "!":
                        addCmd("", "CMDG", "", "");
                        break;
        }
        addCmd("", "DSVF", usaRotulo(), "");
        op = top.image.toString();
        if(tipo1.compareToIgnoreCase("STRING")==0 || tipo2.compareToIgnoreCase("STRING")==0 || tipo1.compareToIgnoreCase("_NULO_")==0 || tipo1.compareToIgnoreCase("_NULO_")==0){
                System.out.println("Erro semantico na linha: "+top.beginLine+", coluna: "+top.beginColumn+".\u005cn\u005ctEsperado INTEGER ou REAL!");
                {if (true) return "_NULO_";}
        }
        else if(tipo1.compareToIgnoreCase("INTEGER")!=0 || tipo2.compareToIgnoreCase("INTEGER")!=0)
                {if (true) return "REAL";}
        else
                {if (true) return "INTEGER";}
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
        {if (true) return tipo1;}
    throw new Error("Missing return statement in function");
  }

//38. Expression ::= Term {AddOp Term}
  static final public String Expression() throws ParseException {
        Token top;
        String op, tipo1, tipo2;
    tipo1 = Term();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_11;
      }
      top = AddOp();
      tipo2 = Term();
                switch(top.image.toString()){
                case "+":
                        addCmd("", "SOMA", "", "");
                        break;
                case "-":
                        addCmd("", "SUBT", "", "");
                        break;
                }
                op =top.image.toString();
        if(op.compareTo("*")==0 || op.compareTo("/")==0){
                if(tipo1.compareTo(tipo2)==0)
                        tipo1 = tipo1;
                else if(tipo1.compareTo("INTEGER")==0 && tipo2.compareTo("REAL")==0)
                        tipo1 = tipo2;
                else if(tipo1.compareTo("REAL")==0 && tipo2.compareTo("INTEGER")==0)
                        tipo1 = tipo1;
                else {
                        System.out.println("Erro semantico na linha: "+top.beginLine+", coluna: "+top.beginColumn+".\u005cn\u005ctTipos incompativeis. ("+tipo1+" "+op+" "+tipo2+")!");
                }
        }
    }
                {if (true) return tipo1;}
    throw new Error("Missing return statement in function");
  }

//39. Term ::= Unary {MultOp Unary}
  static final public String Term() throws ParseException {
        Token top;
        String op, tipo1, tipo2;
    tipo1 = Unary();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULT:
      case DIV:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_12;
      }
      top = MultOp();
      tipo2 = Unary();
                switch(top.image.toString()){
                case "*":
                        addCmd("", "MULT", "", "");
                        break;
                case "/":
                        addCmd("", "DIVI", "", "");
                        break;
                }
                op =top.image.toString();
        if(op.compareTo("*")==0 || op.compareTo("/")==0){
                if(tipo1.compareTo(tipo2)==0)
                        tipo1 = tipo1;
                else if(tipo1.compareTo("INTEGER")==0 && tipo2.compareTo("REAL")==0)
                        tipo1 = tipo2;
                else if(tipo1.compareTo("REAL")==0 && tipo2.compareTo("INTEGER")==0)
                        tipo1 = tipo1;
                else {
                        System.out.println("Erro semantico na linha: "+top.beginLine+", coluna: "+top.beginColumn+".\u005cn\u005ctTipos incompativeis. ("+tipo1+" "+op+" "+tipo2+")!");
                }
        }
    }
                {if (true) return tipo1;}
    throw new Error("Missing return statement in function");
  }

//40. [+ | -] Factor
  static final public String Unary() throws ParseException {
        String type;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ADD:
    case SUB:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
        jj_consume_token(ADD);
        break;
      case SUB:
        jj_consume_token(SUB);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    type = Factor();
        {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

//41. Factor ::=  <Identifier> <ArgListSpecial> | numericLiteral | stringLiteral | â€œ~â€?<Factor> | â€œ(â€? <Condition> â€œ)â€? | <Variable>
  static final public String Factor() throws ParseException {
        Token t;
        int nparams = 0;
        Descritor o = null;
        String typeName = "_NULO_";
        Descritor type = null;
        Token aux;
    if (jj_2_2(2)) {
      t = Identifier(false);
      ArgListSpecial();
                typeName = ts.search(0,t.image.toString()).getRotulo();
                if(typeName.compareToIgnoreCase("FUNCTION")==0){
                        {if (true) return ((Descritor)ts.search(0,t.image.toString()).getCategoria().get("RTYPE")).getRotulo();}
                } else {
                        {if (true) return ts.searchDataType(t.image.toString()).getRotulo();}
                }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        t = jj_consume_token(FLOAT);
                addCmd("", "CRCT", t.image.toString(), "");
                {if (true) return "REAL";}
        break;
      case INTEIRO:
        t = jj_consume_token(INTEIRO);
                addCmd("", "CRCT", t.image.toString(), "");
                {if (true) return "INTEGER";}
        break;
      case CADEIA:
        jj_consume_token(CADEIA);
                {if (true) return "STRING";}
        break;
      case NAO:
        aux = jj_consume_token(NAO);
        typeName = Factor();
        break;
      case ABREPAR:
        jj_consume_token(ABREPAR);
        Condition();
        jj_consume_token(FECPAR);
        break;
      case IDENTIFIER:
                flag = 2;
        typeName = Variable(true, o,false);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return typeName;}
    throw new Error("Missing return statement in function");
  }

//42. Variable ::=<Identifier> [â€œ[â€? <Expression> â€œ]â€?](â€œ.â€?<Variable>)*
  static final public String Variable(boolean inicial, Descritor tipoVar,boolean indexAnterior) throws ParseException {
        Token t;
        Descritor type = null;
        String typeName = null;
        Token nIndex=null;
        boolean index;
        index = false;
    t = Identifier(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABRECOL:
      jj_consume_token(ABRECOL);
      nIndex = jj_consume_token(INTEIRO);
      jj_consume_token(FECHACOL);
                                                                    index = true;
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
                switch(flag){
                        case 0 :
                                break;
                        case 1 :
                                for(int i = nivel; i >=0; i--){
                                        if(posVariaveis.get(t.image.toString()).get(i) != null){
                                                addCmd("", "ARMZ", "" + i, "" + posVariaveis.get(t.image.toString()).get(i));
                                                flag = 0;
                                                break;
                                        }
                                }
                                break;
                        case 2:
                                for(int i = nivel; i >=0; i--){
                                        if(posVariaveis.get(t.image.toString()).get(i) != null)
                                        {
                                                if(parametros.size()!=0)
                                                {
                                                        if(parametros.get(indiceParametro).compareToIgnoreCase("REFERENCE")==0)
                                                                addCmd("", "CREN", "" + i, "" + posVariaveis.get(t.image.toString()).get(i));
                                                        else
                                                                addCmd("", "CRVL", "" + i, "" + posVariaveis.get(t.image.toString()).get(i));
                                                }
                                                else
                                                        addCmd("", "CRVL", "" + i, "" + posVariaveis.get(t.image.toString()).get(i));
                                                flag = 0;
                                                break;
                                        }
                                }
                                break;
                        case 3:
                                for(int i = nivel; i >=0; i--){
                                        if(posVariaveis.get(t.image.toString()).get(i) != null){
                                                flag = 0;
                                                break;
                                        }
                                }
                                break;
                        case 5:
                                cmd = new ArrayList<String>();
                                cmd.add("");
                                cmd.add("ARMZ");
                                for(int i = nivel; i >=0; i--){
                                        if(posVariaveis.get(t.image.toString()).get(i) != null){
                                                cmd.add("" + i);
                                                cmd.add("" + posVariaveis.get(t.image.toString()).get(i));
                                                break;
                                        }
                                }
                                flag = 0;
                                break;

                }
                if(inicial)// Si fuera la variable inicial
        {
            tipoVar=null;
            if(palavrasReservadas.contains(t.image.toString().toLowerCase())||tipoPrimitivo.contains(t.image.toString().toLowerCase()))
                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct O indentificador "+t.image.toString()+" nao pode ser palavra chave.");
            else if(ts.existType(t.image.toString()))
                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct O indentificador "+t.image.toString()+" nao pode ser um tipo de dado.");
            else
            {
                if(ts.existVariable(t.image.toString())||ts.existFunction(t.image.toString()))
                {
                    Descritor var = ts.search(t.image.toString());
                    //System.out.println("BIENMAL: " + (var.getRotulo());
                    if(var.getRotulo().compareTo("VARIABLE")==0||var.getRotulo().compareTo("PARAM")==0)
                        tipoVar = (Descritor) var.getCategoria().get("ELEMTYPE");
                    else if(var.getRotulo().compareTo("FUNCTION")==0)
                        tipoVar = (Descritor) var.getCategoria().get("RTYPE");
                    type = tipoVar;
                    if(tipoVar.getRotulo().compareToIgnoreCase("TYPE")==0)
                    {
                        if(index==true&&((String)tipoVar.getCategoria().get("ROTULO")).compareTo("ARRAY")==0&&index)
                        {
                                int sizeMax=(int)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("SIZE"));
                                int ind =Integer.parseInt(nIndex.image.toString());
                                if(ind<0 || ind>=sizeMax)
                                        System.out.println("Erro semantico na linha "+nIndex.beginLine+", coluna "+nIndex.beginColumn+".\u005cn\u005ctO indice do array  "+t.image.toString()+"  estam fora de seu rango");
                        }
                        while(((String)tipoVar.getCategoria().get("ROTULO")).compareTo("ARRAY")==0 && index)
                                tipoVar=(Descritor)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("ELEMTYPE"));
                    }
                                        if(var.getRotulo().equals("FUNCTION") && !var.getCategoria().get("NPARAMS").equals(0))
                                                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");

                }
                else
                        System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ct Indentificador "+t.image.toString()+" nao foi declarado ou e um procedimento.");
            }
                }
        else//trata campos
        {
                        if(tipoVar == null)
                                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctImpossivel acessar o campo "+t.image.toString()+" porque um ou mais campos anteriores nao foram declarados corretamente.");
                        else if(((String)tipoVar.getCategoria().get("ROTULO")).equals("ARRAY")&&indexAnterior==false)
                                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctImpossivel acessar o campo "+t.image.toString()+" a partir de um array.");
                        else if(((String)tipoVar.getCategoria().get("ROTULO")).equals("RECORD")
                                &&(Descritor)(((RecordTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get(t.image.toString()))== null)
                                System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctCampo "+t.image.toString()+" nao foi declarado.");
            else
            {
                 Descritor var =tipoVar;
                                if(var.getRotulo().compareTo("VARIABLE")==0||var.getRotulo().compareTo("PARAM")==0)
                     tipoVar = (Descritor) var.getCategoria().get("ELEMTYPE");
                else if(var.getRotulo().compareTo("FUNCTION")==0)
                    tipoVar = (Descritor) var.getCategoria().get("RTYPE");
                type = tipoVar;
                if(tipoVar.getRotulo().compareToIgnoreCase("TYPE")==0)
                {
                                        if(((String)(tipoVar.getCategoria()).get("ROTULO")).compareTo("RECORD")==0)
                        {
                                                tipoVar = (Descritor)(((RecordTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get(t.image.toString()));
                                                type = tipoVar;
                        }
                        else if(((String)(tipoVar.getCategoria()).get("ROTULO")).compareTo("ARRAY")==0&&index)
                        {

                            int sizeMax=(int)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("SIZE"));
                            int ind =Integer.parseInt(nIndex.image.toString());
                            if(ind<0 || ind>=sizeMax)
                                System.out.println("Erro semantico na linha "+nIndex.beginLine+", coluna "+nIndex.beginColumn+".\u005cn\u005ctO indice do array  "+t.image.toString()+"  estam fora de seu rango");
                            tipoVar =  (Descritor)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("ELEMTYPE"));
                                                type = tipoVar;
                                                while(((String)tipoVar.getCategoria().get("ROTULO")).compareTo("ARRAY")==0 )
                                        tipoVar=(Descritor)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("ELEMTYPE"));

                        }
                    while(((String)tipoVar.getCategoria().get("ROTULO")).compareTo("ARRAY")==0 && index)
                        tipoVar=(Descritor)(((ArrayTipo)(((Tipo) tipoVar.getCategoria()).get("ELEMTYPE"))).get("ELEMTYPE"));
                }
                                if(var.getRotulo().equals("FUNCTION") && !var.getCategoria().get("NPARAMS").equals(0))
                                        System.out.println("Erro semantico na linha "+t.beginLine+", coluna "+t.beginColumn+".\u005cn\u005ctNumero de argumentos passados para a funcao "+t.image.toString()+" eh diferente do esperado.");
                        }
                }
    label_13:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_13;
      }
      jj_consume_token(DOT);
      typeName = Variable(false, tipoVar,index);
    }
                if(typeName == null)
                {
                        if(type == null || type.getCategoria()== null)
                                typeName = "_NULO_";
                        else
                        {
                                typeName = type.getRotulo();
                                //System.out.println("HMMM: " + type.getRotulo());
                                if(typeName.equals("RECORD")&&index==false )
                {
                        System.out.println("bien");
                                        type = (Descritor)((RecordTipo)type.getCategoria()).get(t.image.toString());
                                        typeName = type.getRotulo();
                                        System.out.println("error");
                                }
                else if(typeName.equals("FUNCTION"))
                                        type = ((Descritor)type.getCategoria().get("RTYPE"));
                                else if(typeName.equals("ARRAY") && index)
                                        type = ((Descritor)type.getCategoria().get("ELEMTYPE"));
                                else if(typeName.equals("VARIABLE"))
                                        type = ((Descritor)type.getCategoria().get("ELEMTYPE"));
                                typeName = type.getId();
                        }
                }
                {if (true) return typeName;}
    throw new Error("Missing return statement in function");
  }

//43. RelOp ::= (= | ! | > | < | <= | >=)
  static final public Token RelOp() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IGUAL:
      t = jj_consume_token(IGUAL);
      break;
    case DIFERENTE:
      t = jj_consume_token(DIFERENTE);
      break;
    case MAIOR:
      t = jj_consume_token(MAIOR);
      break;
    case MENOR:
      t = jj_consume_token(MENOR);
      break;
    default:
      jj_la1[27] = jj_gen;
      if (jj_2_4(2)) {
        t = jj_consume_token(MENORIGUAL);
      } else if (jj_2_5(2)) {
        t = jj_consume_token(MAIORIGUAL);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

//44. AddOp ::= (+ | -)
  static final public Token AddOp() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ADD:
      t = jj_consume_token(ADD);
      break;
    case SUB:
      t = jj_consume_token(SUB);
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

//45. MultOp ::=  (* | /)
  static final public Token MultOp() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULT:
      t = jj_consume_token(MULT);
      break;
    case DIV:
      t = jj_consume_token(DIV);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

//46. Argument ::= Condition
  static final public void Argument() throws ParseException {
    Condition();
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_3R_36() {
    if (jj_scan_token(CADEIA)) return true;
    return false;
  }

  static private boolean jj_3R_35() {
    if (jj_scan_token(INTEIRO)) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    if (jj_3R_27()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_14()) return true;
    if (jj_scan_token(PONTOVIRGULA)) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_scan_token(WRITE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    if (jj_scan_token(CALL)) return true;
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    if (jj_scan_token(UNTIL)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_3R_28()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_15()) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_scan_token(MENORIGUAL)) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(SET)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(ABREPAR)) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3R_30() {
    if (jj_3R_31()) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(READ)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(MAIORIGUAL)) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_scan_token(ABREPAR)) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_37() {
    if (jj_scan_token(NAO)) return true;
    return false;
  }

  static private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) return true;
    }
    return false;
  }

  static private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public TesterTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800,0x0,0x4002,0x80000,0x2002400,0x2002400,0x0,0x1000020,0x1000020,0x20000,0x22002400,0x20000000,0x0,0x4608340,0x4608340,0x810000,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0xc0000000,0xc0000000,0x0,0x0,0x0,0xc0000000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x800,0x0,0x0,0x800,0x800,0x4000,0x0,0x0,0x0,0x800,0x0,0x2000,0x0,0x0,0x0,0x8000,0x4000,0x400000,0x200000,0xfc,0x0,0x3,0x0,0x0,0x89b00,0x20000,0x3c,0x0,0x3,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[5];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Tester(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Tester(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TesterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Tester(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TesterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Tester(TesterTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TesterTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[65];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 65; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
